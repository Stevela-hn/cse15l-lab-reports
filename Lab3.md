# An exploratory view of `grep` as the command-line tool

This report aims to extend on course material about `grep` in CSE 15L and provide a comprehensive view of this tool. There're mainly two parts, the first one introduces the file structure that the author is experimenting in, and the second one follows a series of 8 examples that contains four command-line options or alternate ways to use the command, each of which has two examples.

## Part 1 - File Structure / Setting
The files consists of several folders that contains text-as-data as `.txt` files, which includes conference papers and records. Our working directory will be mostly in the `./technial` project. The project comes with four categories of data in `technical` folder - `911 report`, `biomed`, `government` and `plos`. It is highly possible that not all of the four folders of data will be applied in this report. But at least some of them leave us a good practice on the command tools. Below attached a tree representation of the folder structure: note that the author intentionally ignored some java files and bash files to make the overall structure more clear.

```
- docsearch
  - technical (working dir)
    - 911report
      - .txt files
    - biomed
      - .txt files
    - government
      - 6 sub-categories
        - .txt files
    - plos
      - .txt files
```

## Part 2 - Exploratory `grep`
This section aims to give 4 interesting command-line options or alternate ways to use `grep`, each comes with two examples.

### Section 0: A brief introduction to basic `grep`
`grep` is a command-line tool in Bash that is used for searching through text files for **lines** that contain a specific pattern or string. The name "grep" stands for "global regular expression print". It takes one or more patterns as input and searches through one or more files or standard input, displaying any lines that contain the specified pattern. (Note: this paragraph refers the definition generated by ChatGPT)

### Section 1: Recursive search
The option `-r` enables searching for some patterns/strings in all files under a directory. Remember in lab activities, `grep` is usually used to search on a specific `.txt` file or all `.txt` files in a folder. This is obviously not efficient enough under the cases files are stores as a hierarchical structure. The option `-r` solves the issue in such circumstances. Two examples are attached below. (Reference: the idea comes from the official doc of grep: https://www.gnu.org/software/grep/manual/grep.html)

- Example 1: Searching for lines with word "most recent" in `/911report`
  ```
  $ grep -r "most recent" 911report
  911report/chapter-1.txt:    On 9/11, the defense of U.S. airspace depended on close interaction between two federal agencies: the FAA and the North American Aerospace Defense Command (NORAD). The most recent hijacking that involved U.S. air traffic controllers, FAA management, and military coordination had occurred in 1993.90 In order to understand how the two agencies interacted eight years later, we will review their missions, command and control structures, and working relationship on the morning of 9/11.
  911report/chapter-13.1.txt:                been introduced, most recently a bill by the chairman of the House Intelligence
  911report/chapter-13.1.txt:            "This is government acting in new ways, to face new threats," the most recent Markle
  ```
  
- Example 2: Searching for lines with word "most feasible" in `/government`. Note that this example well-display the ability of hierarchical search, because `/government` has one more level of folder. In general `-r` prints in a way of "[path]: line".
  ```
  $ grep -r "most feasible" government/
  government/Post_Rate_Comm/Redacted_Study.txt:terminal dues appears most feasible among industrialized
  ```

### Section 2: Count Matchings
The `-c` option gives a very clean and clear output, that it instead print a count of matching lines for each input file. Note that in lab activities, the `grep` usually gives us a large amount of output texts, so that we have to save them into the other `.txt` files for further inspection. Admittedly, this enables more insightful exploration, but the author would like to emphasize that with a single `-c` option, the user could get to know the number of matching lines. This could serve as a "preliminary check" to see if some complex grep query gives an expected output. Say the user search by the regex query `'\w*ty\b'` to see how many lines contains words end with "ty", but got a count of 0. This is highly unlikely given it's popularity. In this way the user could immediately know "something's wrong", and get back to revise. Two examples are attached below. (Reference: the idea comes from the official doc of grep: https://www.gnu.org/software/grep/manual/grep.html)


### Section 3: Not Containing/Matching
The option `-v` tells grep to display only the lines that do not match the specified pattern. Users usually face the circumstances that they want to find all lines that "don't have something". To approach this, the author believe that regex is one intuitive way. But after several attempts, the author found ChatGPT always gives some shitty suggestions that doesn't work at all. Fortunately, the option `-v` in grep directly allows such "not-match searching". Two examples are attached below. (References: the idea comes from the official doc of grep: https://www.gnu.org/software/grep/manual/grep.html. Thanks ChatGPT for its stupid attempts with the author's non-native prompts.)


### Section 4: Only-Matching
"I'm done with line-based matching!" The author noted that for whatever options we discussed before, grep in default search the matching among **lines**. But in real world application, lines are still too messy for analysts/NLP researchers - they might just want the **words** that matches some patterns. Unfortunately, the author didn't find an option that clearly states "matching the words". But the option `-o` as only-matching provides the possibility of searching with words. It prints only the matched non-empty parts of matching lines, with each such part on a separate output line. With nice formatted regex, the users could definitely achieve word-wise matching. Two examples are attached below. (References: the idea comes from the official doc of grep: https://www.gnu.org/software/grep/manual/grep.html. Thanks ChatGPT for its regex correctness confirmation.)
